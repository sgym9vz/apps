name: Deploy Django (docker-compose) to EC2

on:
  workflow_dispatch:          # 手動実行
  push:
    branches: [ main ]        # mainにpush時デプロイ
    paths:
      - 'apps/django_intmd/**'
      - '.github/workflows/deploy-django-ec2.yml'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::585008043652:role/github-actions-deploy-role
          aws-region: ap-northeast-1

      - name: Who am I (verify AWS creds)
        run: aws sts get-caller-identity

      - name: Open SSH from runner IP (temp)
        id: open_ssh
        env:
          REGION: ap-northeast-1
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          set -euo pipefail
          RUNNER_IP=$(curl -s https://checkip.amazonaws.com | tr -d '\n')/32
          echo "RUNNER_IP=$RUNNER_IP"
          SG_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${HOST}" \
            --query "Reservations[0].Instances[0].SecurityGroups[0].GroupId" \
            --output text --region "$REGION")
          echo "SG_ID=$SG_ID"
          aws ec2 authorize-security-group-ingress \
            --group-id "$SG_ID" \
            --protocol tcp --port 22 \
            --cidr "$RUNNER_IP" \
            --region "$REGION" || echo "ingress already exists"
          echo "sg_id=$SG_ID" >> "$GITHUB_OUTPUT"
          echo "runner_ip=$RUNNER_IP" >> "$GITHUB_OUTPUT"

      # SSH 経由で EC2 上のリポを更新→compose up
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail

            # 1) 依存(初回のみ有効)
            if ! command -v docker &>/dev/null; then
              sudo dnf -y update
              sudo dnf -y install docker
              sudo systemctl enable --now docker
            fi
            if ! docker compose version &>/dev/null; then
              # Install Docker Compose v2 as a CLI plugin (fallback for AL2023)
              sudo dnf -y install curl || true
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -sSL "https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64" \
                -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
              docker compose version
            fi

            # git が無ければ導入（AL2023 最小AMIは入っていない）
            if ! command -v git &>/dev/null; then
              sudo dnf -y install git
            fi

            # 2) リポジトリを用意（まだ無ければclone）
            mkdir -p ~/apps && cd ~/apps
            if [ ! -d apps ]; then
              git clone https://github.com/sgym9vz/apps.git
            fi
            cd apps
            git fetch --all
            git reset --hard origin/main

            # 3) アプリディレクトリへ（repo直下の django_intmd に docker-compose.yml がある想定）
            cd django_intmd || { echo "path not found: $(pwd)/django_intmd"; ls -la; exit 1; }
            test -f docker-compose.yml || { echo "docker-compose.yml not found in $(pwd)"; ls -la; exit 1; }

            # 3.5) ディスク空き容量の確認とクリーンアップ（足りないとpull/extractで失敗する）
            echo "== Disk before =="
            df -h /
            echo "== Docker usage before =="
            sudo docker system df || true

            # 低空き容量なら徹底清掃
            AVAIL_KB=$(df -k / | awk 'NR==2{print $4}')
            # 例: 5GB 未満ならクリーンアップ（任意閾値）
            if [ "$AVAIL_KB" -lt 5000000 ]; then
              echo "Low free space; pruning docker and caches..."
              sudo docker system prune -af --volumes || true
              sudo docker image prune -af || true
              sudo journalctl --vacuum-time=3d || true
              sudo dnf clean all || true
              sudo rm -rf /var/cache/dnf || true
              echo "== Disk after prune =="
              df -h /
              echo "== Docker usage after =="
              sudo docker system df || true

              # まだ 3GB 未満なら明示的に失敗（EBS拡張が必要）
              AVAIL_KB2=$(df -k / | awk 'NR==2{print $4}')
              if [ "$AVAIL_KB2" -lt 3000000 ]; then
                echo "ERROR: Free space still too low (<3GB). Consider increasing root volume size." >&2
                exit 1
              fi
            fi

            # 4) 既存で80番を掴むコンテナを止める（初回のnginx対策）
            sudo docker ps -q --filter 'publish=80' | xargs -r sudo docker rm -f || true

            # 5) compose ビルド＆起動
            #   ※ nginxのportsが "80:8080" になっている想定
            sudo docker compose up -d --build

            # 6) ヘルスチェック簡易
            sleep 5
            curl -fsS http://localhost/ >/dev/null || (sudo docker compose logs --no-color --tail=100; false)

      - name: Close SSH from runner IP (cleanup)
        if: always()
        env:
          REGION: ap-northeast-1
        run: |
          SG_ID='${{ steps.open_ssh.outputs.sg_id }}'
          RUNNER_IP='${{ steps.open_ssh.outputs.runner_ip }}'
          if [ -n "$SG_ID" ] && [ -n "$RUNNER_IP" ]; then
            aws ec2 revoke-security-group-ingress \
              --group-id "$SG_ID" \
              --protocol tcp --port 22 \
              --cidr "$RUNNER_IP" \
              --region "$REGION" || true
          fi

      # 成功時にJobサマリーへIPを出す
      - name: Show URL
        if: success()
        run: |
          echo "## Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- URL: http://${{ secrets.EC2_HOST }}/" >> $GITHUB_STEP_SUMMARY